package auth

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"fmt"
	"hash"
	"math/rand"
	"strconv"
	"strings"
	"time"

	"golang.org/x/crypto/pbkdf2"
)

const (
	// UnuablePasswordPrefix This will never be a valid encoded hash
	UnuablePasswordPrefix = "!"
	// UnuablePasswordPrefixLength number of random chars to add after UnuablePasswordPrefix
	UnuablePasswordPrefixLength = 40
)

// Return True if this password wasn't generated by make_password("")
func isPasswordUsable(encoded string) bool {

	return encoded == "" || strings.HasPrefix(encoded, UnuablePasswordPrefix)
}

func getRandomString(length int) string {

	allowedChars := []byte("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
	s := []byte{}
	r := rand.New(rand.NewSource(time.Now().UnixNano()))
	for i := 0; i < length; i++ {
		s = append(s, allowedChars[r.Intn(len(allowedChars))])
	}
	return string(s)
}

func constantTimeCompare(val1, val2 string) bool {

	return hmac.Equal([]byte(val1), []byte(val2))
}

// MakePassword return the password encrypted by hash
func MakePassword(rawPassword string) string {

	if rawPassword == "" {
		return UnuablePasswordPrefix + getRandomString(UnuablePasswordPrefixLength)
	}

	hasher := NewPBKDF2PasswordHasher()
	salt := hasher.Salt()
	return hasher.Encode(rawPassword, salt, 0)
}

// CheckPassword Return a boolean of whether the raw password matches the three part encoded digest
func CheckPassword(rawPassword, encoded string) bool {

	if isPasswordUsable(encoded) {
		return false
	}

	hasher := NewPBKDF2PasswordHasher()
	return hasher.Verify(rawPassword, encoded)
}

// PBKDF2PasswordHasher Secure password hashing using the PBKDF2 algorithm
// PBKDF2 + HMAC + SHA256
type PBKDF2PasswordHasher struct {
	algorithm  string
	iterations int
	digest     func() hash.Hash
}

// NewPBKDF2PasswordHasher return *NewPBKDF2PasswordHasher
func NewPBKDF2PasswordHasher() *PBKDF2PasswordHasher {

	return &PBKDF2PasswordHasher{
		algorithm:  "pbkdf2_sha256",
		iterations: 150000,
		digest:     sha256.New,
	}
}

// Salt Generate a cryptographically secure nonce salt in ASCII
func (hasher PBKDF2PasswordHasher) Salt() string {

	return getRandomString(12)
}

// Encode return hash string
// return "" if input param is invalid
func (hasher PBKDF2PasswordHasher) Encode(password, salt string, iterations int) string {

	if password == "" {
		return ""
	}
	if salt == "" || strings.Contains(salt, "$") {
		return ""
	}
	if iterations <= 0 {
		iterations = hasher.iterations
	}

	//pbkdf2 算法加密
	hashBytes := pbkdf2.Key([]byte(password), []byte(salt), iterations, 32, hasher.digest)
	//Base64 编码
	hashStr := base64.StdEncoding.EncodeToString(hashBytes)
	// 拼接字符串
	hashSecret := fmt.Sprintf("%s$%d$%s$%s", hasher.algorithm, iterations, salt, hashStr)
	return hashSecret
}

// Verify Check if the given password is correct
func (hasher PBKDF2PasswordHasher) Verify(password, encoded string) bool {

	a := strings.SplitN(encoded, "$", 4)
	if len(a) != 4 {
		return false
	}
	algorithm := a[0]
	iterations, err := strconv.ParseUint(a[1], 10, 64)
	if err != nil {
		return false
	}
	salt := a[2]

	if hasher.algorithm != algorithm {
		return false
	}

	encoded2 := hasher.Encode(password, salt, int(iterations))
	return constantTimeCompare(encoded, encoded2)
}

//     def safe_summary(self, encoded):
//         algorithm, iterations, salt, hash = encoded.split('$', 3)
//         assert algorithm == self.algorithm
//         return OrderedDict([
//             (_('algorithm'), algorithm),
//             (_('iterations'), iterations),
//             (_('salt'), mask_hash(salt)),
//             (_('hash'), mask_hash(hash)),
//         ])

//     def must_update(self, encoded):
//         algorithm, iterations, salt, hash = encoded.split('$', 3)
//         return int(iterations) != self.iterations

//     def harden_runtime(self, password, encoded):
//         algorithm, iterations, salt, hash = encoded.split('$', 3)
//         extra_iterations = self.iterations - int(iterations)
//         if extra_iterations > 0:
//             self.encode(password, salt, extra_iterations)
